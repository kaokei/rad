<h1 align="center">rad</h1>

## github 地址

- [github](https://github.com/kaokei/rad)

## 解决了什么问题？

本来的打算是随机生成一组数字，但是同时想要足够的平均分布。现在有三种方案。

方案一：randomMulti

多次调用 randomOne，每次调用都是独立的。

方案二：evenlyDistributed

先把区间平均分成 N 份小区间，然后在每个小区间中调用 randomOne。

方案三：randomDistribution

不像方案一都是独立的在整个区间重复调用 randomOne。

也不像方案二，先平均分割区间，然后在每一个独立的小区间获取随机数。

方案三整体上比较像方案二，但是关键区别是不是固定分割正 N 份小区间，每个小区间都是动态分割的。
动态分割的原则是把上一次小区间的结束点当作下一次小区间的开始点，同时保证每次小区间的中心点和方案二的小区间的中心点一致。

## 方案结果分析

实验介绍：[N, X, Y]，代表从 X ～ Y 区间内获取 N 个随机数。

#### 计算所有点的方差的平均值

每个实验重复了`999999`次，然后计算每次实验的方差，然后计算`999999`次实验的方差的平均值。

|          实验           |      方案一       |      方案二       |      方案三       |
| :---------------------: | :---------------: | :---------------: | :---------------: |
|      [10, 10, 20]       | 8.252475385808719 | 9.166666666666666 | 9.209847243180576 |
|     [100, 200, 300]     | 833.0819312473858 | 841.6666666666666 | 841.8500780808862 |
|   [100, 20000, 30000]   | 8333253.217962939 | 8417473.331720132 | 8417988.098825537 |
|   [1000, 3000, 4000]    | 83330.70708807863 | 83416.66666666667 | 83416.83278424051 |
|  [1000, 30000, 40000]   | 8333657.196446534 | 8341674.78936479  | 8341683.896522445 |
|  [10000, 40000, 50000]  | 8333425.416601894 | 8334166.666666667 | 8334166.894598825 |
| [10000, 400000, 500000] | 833345603.0048352 | 833416678.1441561 | 833416675.8027935 |

#### 计算所有点的所有距离的平均值

每个实验重复了`9999`次，然后计算每次实验的所有点之间的总距离，然后计算`9999`次实验的总距离的平均值。

|          实验           |       方案一       |       方案二       |       方案三       |
| :---------------------: | :----------------: | :----------------: | :----------------: |
|      [10, 10, 20]       | 148.42154215421542 |        165         | 159.4152415241524  |
|     [100, 200, 300]     | 164924.1313131313  |       166650       | 166585.6787678768  |
|   [100, 20000, 30000]   | 16492614.758775877 | 16665088.809780978 | 16661934.168416841 |
|   [1000, 3000, 4000]    | 166476310.54945496 |     166666500      | 166665775.3212321  |
|  [1000, 30000, 40000]   | 1665350644.9377937 | 1666664603.8289828 | 1666661881.3132312 |
|  [10000, 40000, 50000]  | 166648706091.47205 |    166666665000    | 166666656572.44916 |
| [10000, 400000, 500000] | 1666452658179.0918 | 1666666649632.567  | 1666666667495.2444 |

#### 计算所有点的最大距离的平均值

每个实验重复了`9999`次，然后计算每次实验的所有点之间的最大距离，然后计算`9999`次实验的最大距离的平均值。

|          实验           |      方案一       |      方案二       |      方案三       |
| :---------------------: | :---------------: | :---------------: | :---------------: |
|      [10, 10, 20]       | 8.008200820082008 |         9         | 8.439443944394439 |
|     [100, 200, 300]     | 97.82458245824583 |        99         | 98.45024502450245 |
|   [100, 20000, 30000]   | 9798.96189618962  | 9899.846784678468 | 9870.76397639764  |
|   [1000, 3000, 4000]    | 997.8632863286329 |        999        | 998.4559455945595 |
|  [1000, 30000, 40000]   | 9979.994799479948 | 9989.970497049704 | 9986.830483048305 |
|  [10000, 40000, 50000]  | 9997.855485548554 |       9999        | 9998.459345934594 |
| [10000, 400000, 500000] | 99980.13851385139 | 99990.01610161016 | 99986.84378437843 |

## 总结

通过上面的数据可以发现，三种算法得到的随机结果差别不大，基本可以说没有差别，这一点是完全出乎意料之外的。
我本来的预期是方案一可能会相对比较集中，不够平均分布。方案二则是太过于平均。方案三则是介于方案一和方案二之间。
虽然从数据上分析来看，从相对数据来说大多数实验确实是符合预期的，但是效果太不明显，效果基本可以忽略不计。

尤其是从最大距离这个角度来看，因为生成的所有点之间的最大距离越大，说明分布越平均。方案一最小，方案二最大，方案三在中间。
只不过大家都在一个数量级别，没有明显的效果提升。

但是我总觉得这几种方案还是存在差异的，只不过没有找到一个好的指标来衡量这种差异。

这里是我写的一个[简单的 demo](https://codesandbox.io/s/lively-http-u0z31?file=/src/App.vue)，可以在线生成一些随机数。
